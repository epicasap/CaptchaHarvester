#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# A simple native messaging host. Shows a Tkinter dialog with incoming messages
# that also allows to send message back to the webapp.


import socket
import struct
import sys
import threading
import sys
import os
import json

if (sys.version_info > (3, 0)):
    import socketserver
    import queue
else:
    import SocketServer as socketserver
    import Queue as queue


# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
    import os
    import msvcrt
    msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
    msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

__dir__ = os.path.dirname(os.path.abspath(__file__))
PROC_PORT_FILE = os.path.join(__dir__, 'proc.port')


class MyUDPHandler(socketserver.BaseRequestHandler):
    def handle(self):
        data = self.request[0].strip()
        data = json.loads(data)
        send_message({"udp": data})
        socket = self.request[1]
        # print("{} wrote:".format(self.client_address[0]))
        # print(data)
        socket.sendto('OK', self.client_address)


def send_message(message):
    message = json.dumps(message)
    sys.stdout.write(struct.pack('I', len(message)))
    sys.stdout.write(message)
    sys.stdout.flush()


def read_thread_func(queue):
    while 1:
        # Read the message length (first 4 bytes).
        text_length_bytes = sys.stdin.read(4)

        if len(text_length_bytes) == 0:
            if queue:
                queue.put(None)
            sys.exit(0)

        # Unpack message length as 4 byte integer.
        text_length = struct.unpack('i', text_length_bytes)[0]

        # Read the text (JSON object) of the message.
        text = sys.stdin.read(text_length).decode('utf-8')
        # In headless mode just send an echo message back.
        send_message('{"echo": %s}' % text)


if __name__ == '__main__':
    server = socketserver.UDPServer(('127.0.0.1', 9999), MyUDPHandler)
    with open(PROC_PORT_FILE, 'w') as f:
        f.write(str(server.socket.getsockname()[1]))

    server_thread = threading.Thread(target=lambda: server.serve_forever())
    server_thread.daemon = True
    server_thread.start()

    read_thread_func(None)
    os.remove(PROC_PORT_FILE)
